/*Copyright (c) 2016-2017 wavemaker.com All Rights Reserved.
 This software is the confidential and proprietary information of wavemaker.com You shall not disclose such Confidential Information and shall use it only in accordance
 with the terms of the source code license agreement you entered into with wavemaker.com*/
package com.vcs_demo_nov27.controller;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/


import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.hibernate.TypeMismatchException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;

import com.wavemaker.runtime.data.exception.EntityNotFoundException;
import com.wavemaker.runtime.data.export.ExportType;
import com.wavemaker.runtime.data.expression.QueryFilter;
import com.wavemaker.runtime.data.model.AggregationInfo;
import com.wavemaker.runtime.file.model.DownloadResponse;
import com.wavemaker.runtime.file.model.Downloadable;
import com.wavemaker.runtime.util.WMMultipartUtils;
import com.wavemaker.runtime.util.WMRuntimeUtils;
import com.wavemaker.tools.api.core.annotations.WMAccessVisibility;
import com.wavemaker.tools.api.core.models.AccessSpecifier;
import com.wordnik.swagger.annotations.Api;
import com.wordnik.swagger.annotations.ApiOperation;
import com.wordnik.swagger.annotations.ApiParam;

import com.vcs_demo_nov27.NewTable;
import com.vcs_demo_nov27.service.NewTableService;


/**
 * Controller object for domain model class NewTable.
 * @see NewTable
 */
@RestController("viewsdb.NewTableController")
@Api(value = "NewTableController", description = "Exposes APIs to work with NewTable resource.")
@RequestMapping("/viewsdb/NewTable")
public class NewTableController {

    private static final Logger LOGGER = LoggerFactory.getLogger(NewTableController.class);

    @Autowired
	@Qualifier("viewsdb.NewTableService")
	private NewTableService newTableService;

	@ApiOperation(value = "Creates a new NewTable instance.")
@RequestMapping(method = RequestMethod.POST, consumes = "multipart/form-data")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
public NewTable createNewTable(@RequestPart("wm_data_json") NewTable newTable, @RequestPart(value = "column3", required = false) MultipartFile _column3) {
		LOGGER.debug("Create NewTable with information: {}" , newTable);

    newTable.setColumn3(WMMultipartUtils.toByteArray(_column3));
		newTable = newTableService.create(newTable);
		LOGGER.debug("Created NewTable with information: {}" , newTable);

	    return newTable;
	}

    @ApiOperation(value = "Returns the NewTable instance associated with the given id.")
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public NewTable getNewTable(@PathVariable("id") Integer id) throws EntityNotFoundException {
        LOGGER.debug("Getting NewTable with id: {}" , id);

        NewTable foundNewTable = newTableService.getById(id);
        LOGGER.debug("NewTable details with id: {}" , foundNewTable);

        return foundNewTable;
    }

    @ApiOperation(value = "Retrieves content for the given BLOB field in NewTable instance" )
    @RequestMapping(value = "/{id}/content/{fieldName}", method = RequestMethod.GET, produces="application/octet-stream")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public DownloadResponse getNewTableBLOBContent(@PathVariable("id") Integer id, @PathVariable("fieldName") String fieldName, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, @RequestParam(value="download", defaultValue = "false") boolean download) {

        LOGGER.debug("Retrieves content for the given BLOB field {} in NewTable instance" , fieldName);

        if(!WMRuntimeUtils.isLob(NewTable.class, fieldName)) {
            throw new TypeMismatchException("Given field " + fieldName + " is not a valid BLOB type");
        }
        NewTable newTable = newTableService.getById(id);

        return WMMultipartUtils.buildDownloadResponseForBlob(newTable, fieldName, httpServletRequest, download);
    }

    @ApiOperation(value = "Updates the NewTable instance associated with the given id.")
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.PUT)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public NewTable editNewTable(@PathVariable("id") Integer id, @RequestBody NewTable newTable) throws EntityNotFoundException {
        LOGGER.debug("Editing NewTable with id: {}" , newTable.getId());

        newTable.setId(id);
        newTable = newTableService.update(newTable);
        LOGGER.debug("NewTable details with id: {}" , newTable);

        return newTable;
    }

    @ApiOperation(value = "Updates the NewTable instance associated with the given id.This API should be used when NewTable instance fields that require multipart data.") 
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.POST, consumes = {"multipart/form-data"})
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public NewTable editNewTable(@PathVariable("id") Integer id, MultipartHttpServletRequest multipartHttpServletRequest) throws EntityNotFoundException {
        NewTable newNewTable = WMMultipartUtils.toObject(multipartHttpServletRequest, NewTable.class, "viewsdb");
        newNewTable.setId(id);

        NewTable oldNewTable = newTableService.getById(id);
        WMMultipartUtils.updateLobsContent(oldNewTable, newNewTable);
        LOGGER.debug("Updating NewTable with information: {}" , newNewTable);

        return newTableService.update(newNewTable);
    }

    @ApiOperation(value = "Deletes the NewTable instance associated with the given id.")
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.DELETE)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public boolean deleteNewTable(@PathVariable("id") Integer id) throws EntityNotFoundException {
        LOGGER.debug("Deleting NewTable with id: {}" , id);

        NewTable deletedNewTable = newTableService.delete(id);

        return deletedNewTable != null;
    }

    /**
     * @deprecated Use {@link #findNewTables(String, Pageable)} instead.
     */
    @Deprecated
    @ApiOperation(value = "Returns the list of NewTable instances matching the search criteria.")
    @RequestMapping(value = "/search", method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<NewTable> searchNewTablesByQueryFilters( Pageable pageable, @RequestBody QueryFilter[] queryFilters) {
        LOGGER.debug("Rendering NewTables list");
        return newTableService.findAll(queryFilters, pageable);
    }

    @ApiOperation(value = "Returns the paginated list of NewTable instances matching the optional query (q) request param. If there is no query provided, it returns all the instances. Pagination & Sorting parameters such as page& size, sort can be sent as request parameters. The sort value should be a comma separated list of field names & optional sort order to sort the data on. eg: field1 asc, field2 desc etc ")
    @RequestMapping(method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<NewTable> findNewTables(@ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
        LOGGER.debug("Rendering NewTables list");
        return newTableService.findAll(query, pageable);
    }

    @ApiOperation(value = "Returns the paginated list of NewTable instances matching the optional query (q) request param. This API should be used only if the query string is too big to fit in GET request with request param. The request has to made in application/x-www-form-urlencoded format.")
    @RequestMapping(value="/filter", method = RequestMethod.POST, consumes= "application/x-www-form-urlencoded")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<NewTable> filterNewTables(@ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
        LOGGER.debug("Rendering NewTables list");
        return newTableService.findAll(query, pageable);
    }

    @ApiOperation(value = "Returns downloadable file for the data matching the optional query (q) request param. If query string is too big to fit in GET request's query param, use POST method with application/x-www-form-urlencoded format.")
    @RequestMapping(value = "/export/{exportType}", method = {RequestMethod.GET,  RequestMethod.POST}, produces = "application/octet-stream")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Downloadable exportNewTables(@PathVariable("exportType") ExportType exportType, @ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
         return newTableService.export(exportType, query, pageable);
    }

	@ApiOperation(value = "Returns the total count of NewTable instances matching the optional query (q) request param. If query string is too big to fit in GET request's query param, use POST method with application/x-www-form-urlencoded format.")
	@RequestMapping(value = "/count", method = {RequestMethod.GET, RequestMethod.POST})
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Long countNewTables( @ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query) {
		LOGGER.debug("counting NewTables");
		return newTableService.count(query);
	}

    @ApiOperation(value = "Returns aggregated result with given aggregation info")
	@RequestMapping(value = "/aggregations", method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Page<Map<String, Object>> getNewTableAggregatedValues(@RequestBody AggregationInfo aggregationInfo, Pageable pageable) {
        LOGGER.debug("Fetching aggregated results for {}", aggregationInfo);
        return newTableService.getAggregatedValues(aggregationInfo, pageable);
    }


    /**
	 * This setter method should only be used by unit tests
	 *
	 * @param service NewTableService instance
	 */
	protected void setNewTableService(NewTableService service) {
		this.newTableService = service;
	}

}

